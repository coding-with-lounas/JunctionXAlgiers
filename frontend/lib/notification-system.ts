export interface BassinNotification {
  id: string
  bassinId: string
  bassinName: string
  type: "danger" | "warning" | "info"
  category: "water_quality" | "system" | "maintenance" | "alert"
  title: string
  message: string
  timestamp: string
  isRead: boolean
  priority: "high" | "medium" | "low"
  parameters?: {
    parameter: string
    currentValue: number
    threshold: number
    unit: string
  }
  actionRequired?: boolean
  autoGenerated: boolean
}

export interface NotificationManager {
  addNotification: (notification: Omit<BassinNotification, "id" | "timestamp">) => void
  getNotifications: (limit?: number) => BassinNotification[]
  markAsRead: (notificationId: string) => void
  markAllAsRead: () => void
  deleteNotification: (notificationId: string) => void
  clearAllNotifications: () => void
  getUnreadCount: () => number
  getNotificationsByBassin: (bassinId: string) => BassinNotification[]
  generateBassinRiskNotification: (bassinData: any) => void
}

class NotificationService implements NotificationManager {
  private storageKey = "aquaculture-notifications"

  private loadNotifications(): BassinNotification[] {
    try {
      const stored = localStorage.getItem(this.storageKey)
      if (!stored) return []
      return JSON.parse(stored) as BassinNotification[]
    } catch (error) {
      console.error("Failed to load notifications:", error)
      return []
    }
  }

  private saveNotifications(notifications: BassinNotification[]): void {
    try {
      // Keep only last 100 notifications to prevent storage overflow
      const limited = notifications.slice(0, 100)
      localStorage.setItem(this.storageKey, JSON.stringify(limited))
    } catch (error) {
      console.error("Failed to save notifications:", error)
    }
  }

  addNotification(notification: Omit<BassinNotification, "id" | "timestamp">): void {
    const newNotification: BassinNotification = {
      id: `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      ...notification,
    }

    const existing = this.loadNotifications()
    const updated = [newNotification, ...existing]
    this.saveNotifications(updated)

    // Trigger browser notification if permission granted
    if (notification.type === "danger" && "Notification" in window && Notification.permission === "granted") {
      new Notification(`ðŸš¨ ${notification.title}`, {
        body: notification.message,
        icon: "/favicon.ico",
        tag: notification.bassinId,
      })
    }
  }

  getNotifications(limit?: number): BassinNotification[] {
    const notifications = this.loadNotifications()
    return limit ? notifications.slice(0, limit) : notifications
  }

  markAsRead(notificationId: string): void {
    const notifications = this.loadNotifications()
    const updated = notifications.map((n) => (n.id === notificationId ? { ...n, isRead: true } : n))
    this.saveNotifications(updated)
  }

  markAllAsRead(): void {
    const notifications = this.loadNotifications()
    const updated = notifications.map((n) => ({ ...n, isRead: true }))
    this.saveNotifications(updated)
  }

  deleteNotification(notificationId: string): void {
    const notifications = this.loadNotifications()
    const updated = notifications.filter((n) => n.id !== notificationId)
    this.saveNotifications(updated)
  }

  clearAllNotifications(): void {
    localStorage.removeItem(this.storageKey)
  }

  getUnreadCount(): number {
    return this.loadNotifications().filter((n) => !n.isRead).length
  }

  getNotificationsByBassin(bassinId: string): BassinNotification[] {
    return this.loadNotifications().filter((n) => n.bassinId === bassinId)
  }

  generateBassinRiskNotification(bassinData: any): void {
    const {
      id,
      name,
      status,
      activeAlerts,
      temperature,
      ph,
      dissolvedOxygen,
      ammonia,
      nitrite,
      nitrate,
      waterLevel,
      turbidity,
    } = bassinData

    // Generate notifications based on bassin status and parameters
    if (status === "poor") {
      this.addNotification({
        bassinId: id,
        bassinName: name,
        type: "danger",
        category: "water_quality",
        title: `Critical: ${name} Status Poor`,
        message: `${name} is in critical condition with ${activeAlerts} active alerts. Immediate attention required.`,
        isRead: false,
        priority: "high",
        actionRequired: true,
        autoGenerated: true,
      })
    } else if (status === "warning") {
      this.addNotification({
        bassinId: id,
        bassinName: name,
        type: "warning",
        category: "water_quality",
        title: `Warning: ${name} Needs Attention`,
        message: `${name} has ${activeAlerts} active alerts and requires monitoring.`,
        isRead: false,
        priority: "medium",
        actionRequired: true,
        autoGenerated: true,
      })
    }

    // Check individual parameters for specific alerts
    const parameterChecks = [
      { param: "temperature", value: temperature, unit: "Â°C", safe: 20, warning: 22, dangerous: 25 },
      { param: "ph", value: ph, unit: "", safe: 7.5, warning: 8.0, dangerous: 8.5 },
      {
        param: "dissolvedOxygen",
        value: dissolvedOxygen,
        unit: "mg/L",
        safe: 7,
        warning: 6,
        dangerous: 5,
        reverse: true,
      },
      { param: "ammonia", value: ammonia, unit: "mg/L", safe: 0.5, warning: 1.0, dangerous: 2.0 },
      { param: "nitrite", value: nitrite, unit: "mg/L", safe: 0.2, warning: 0.5, dangerous: 1.0 },
      { param: "nitrate", value: nitrate, unit: "mg/L", safe: 20, warning: 30, dangerous: 50 },
      { param: "waterLevel", value: waterLevel, unit: "%", safe: 90, warning: 85, dangerous: 80, reverse: true },
      { param: "turbidity", value: turbidity, unit: "NTU", safe: 5, warning: 8, dangerous: 12 },
    ]

    parameterChecks.forEach(({ param, value, unit, safe, warning, dangerous, reverse = false }) => {
      let alertType: "danger" | "warning" | null = null
      let threshold = 0

      if (reverse) {
        // For parameters where lower values are worse (DO, water level)
        if (value <= dangerous) {
          alertType = "danger"
          threshold = dangerous
        } else if (value <= warning) {
          alertType = "warning"
          threshold = warning
        }
      } else {
        // For parameters where higher values are worse
        if (value >= dangerous) {
          alertType = "danger"
          threshold = dangerous
        } else if (value >= warning) {
          alertType = "warning"
          threshold = warning
        }
      }

      if (alertType) {
        const paramName = param.charAt(0).toUpperCase() + param.slice(1).replace(/([A-Z])/g, " $1")
        this.addNotification({
          bassinId: id,
          bassinName: name,
          type: alertType,
          category: "water_quality",
          title: `${alertType === "danger" ? "Critical" : "Warning"}: ${paramName} Alert`,
          message: `${paramName} in ${name} is ${alertType === "danger" ? "critically" : ""} ${reverse ? "low" : "high"}: ${value.toFixed(2)}${unit} (threshold: ${threshold}${unit})`,
          isRead: false,
          priority: alertType === "danger" ? "high" : "medium",
          parameters: {
            parameter: param,
            currentValue: value,
            threshold,
            unit,
          },
          actionRequired: alertType === "danger",
          autoGenerated: true,
        })
      }
    })
  }
}

export const notificationService = new NotificationService()

// Request notification permission on app load
if ("Notification" in window && Notification.permission === "default") {
  Notification.requestPermission()
}
